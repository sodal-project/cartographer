const core = require('../../core/core.js');
const csv = require('./csvPane.js');
const { consoleLog } = require('../../core/log.js');

// Default Configuration
// TODO: move this to config database
const directorySource = core.source.getSourceObject('directory', 'v1', 'Directory V1');

const directoryTableConfig = {
  tableFormId: "directory-table-form",
  action: {
    label: "Delete",
    endpoint: "/mod/directory/deletePersonas",
  },
  forceFilters: [
    {
      type: "field",
      key: "platform",
      value: "directory",
      operator: "=",
      not: false
    }
  ],
}

const personaTableConfig = {
  tableFormId: "persona-table-form",
  forceFilters: [
    {
      type: "compare",
      key: "not",
      filter: [
        {
          type: "field",
          key: "platform",
          value: "directory",
          operator: "=",
          not: false
        },
        {
          type: "field",
          key: "type",
          value: "participant",
          operator: "=",
          not: false
        }
      ]
    }
  ],
}

/**
 * @description Render the Directory main page
 * 
 * The main page renders two tables:
 * -- The Directory table, which displays all personas in the directory
 * -- The Personas table, which displays all non-participant personas in the graph
 * 
 * The main page also includes forms for adding participants and activities to the directory
 * 
 * @param {object} formData - Form data generated by Directory iterations
 * @returns {string} - Compiled HTML content for the Directory pane
 */
async function redraw() {
  const directoryTableHtml = await core.mod.personaTable.getTable(directoryTableConfig);
  const personaTableHtml = await core.mod.personaTable.getTable(personaTableConfig);
  
  const data = {
    directoryTableHtml,
    personaTableHtml
  };
  
  // Render the mainPane.hbs template
  return core.client.render('mainPane.hbs', data);
}

/**
 * @description The main interface for the module.
 * @returns {string} - Compiled HTML content
 */
async function mainPane() {
  return redraw();
}

/**
 * @description Add a participant to the graph
 * 
 * @param {object} formData - Data from the Add Participant form
 * @returns {string} - Compiled HTML content for the Directory pane
 */
async function addParticipant(formData) {
  // Extract the form data
  const data = { 
    firstName: formData.firstName,
    lastName: formData.lastName,
    handle: formData.handle,
  };

  // Generate a new ID for the participant
  const id = await nextId("Participant");

  // Build a friendly name from the form data
  let name = (data.firstName ? `${data.firstName}` : "");
  name += (data.lastName ? ` ${data.lastName}` : "");
  name += (data.handle ? ` (${data.handle})` : "");

  // Build the persona object
  const personaObject = {
    upn: "upn:directory:participant:" + id,
    type: "participant",
    platform: "directory",
    id: id.toString(),
    name: name,
    ...data
  }
  core.check.personaObject(personaObject);

  consoleLog(`Adding participant: ${JSON.stringify(personaObject)}`);

  await core.graph.mergePersona(personaObject, directorySource);

  return redraw();
}

/**
 * @description Add an activity to the graph
 * 
 * @param {object} formData - The data from Add Activity form
 * @returns {string} - Compiled HTML content for the Directory pane
 */
async function addActivity(formData) {
  // Extract the form data
  const data = { 
    name: formData.name,
  };

  // Generate a new ID for the activity
  const id = await nextId("Activity");

  // Build the persona object
  const activityObject = {
    upn: "upn:directory:activity:" + id,
    type: "activity",
    platform: "directory",
    id: id.toString(),
    ...data
  }

  core.check.personaObject(activityObject);

  console.log(`Adding activity: ${JSON.stringify(activityObject)}`);

  await core.graph.mergePersona(activityObject, directorySource);

  return redraw();
}

async function addPersona(formData) {
  const data = {
    upn: formData.upn,
  }

  if(!data.upn) {
    console.error("No UPN provided");
    return redraw();
  }

  console.log(`Adding persona: ${data.upn}`);

  const persona = core.persona.newFromUpn(data.upn);

  await core.graph.mergePersona(persona, directorySource);

  return redraw();
}

/**
 * @description Delete personas from the directory
 * 
 * @param {object} formData - The data from the Delete Personas request
 * @returns {string} - Compiled HTML content for the Directory pane
 */
async function deletePersonas(formData) {
  const upns = await core.mod.personaTable.getSelectedUpns(formData.tableFormId);

  // Remove the personas from the graph
  for(const upn of upns) {
    await core.graph.deletePersona(upn);
  }

  // Remove the deleted persona UPNs from the selectedUPNs array in the config database
  await core.mod.personaTable.removeSelectedUpns(upns, formData.tableFormId);

  // Update the table
  return core.mod.personaTable.update(formData);
}

/**
 * @description Link personas in the directory
 * 
 * @param {object} formData - The data from the Link Personas request
 * @returns {string} - Compiled HTML content for the Directory pane
 */
async function linkPersonas() {
  const personas = [];
  const directoryUpns = await core.mod.personaTable.getSelectedUpns("directory-table-form");
  const personaUpns = await core.mod.personaTable.getSelectedUpns("persona-table-form");

  if(directoryUpns.length < 1 || personaUpns.length < 1) {
    throw new Error("Both directory and persona must be selected");
  }

  // Set the control level and confidence
  const level = 9 // ADMIN
  const confidence = .5;

  // Generate link queries; all selected directory upns will be linked to all selected personas
  for(const directoryUpn of directoryUpns) {
    for(const personaUpn of personaUpns) {
      const persona = core.persona.newFromUpn(personaUpn);
      persona.obey.push({
        upn: directoryUpn,
        level: level,
        confidence: confidence,
      })
      personas.push(persona);
    }
  }

  await core.graph.mergePersonas(personas, directorySource);
  consoleLog(`Processed ${personas.length} persona links`);

  return redraw();
}

async function unlinkPersonas(formData) {
  // Extract the form data
  const upns = Array.isArray(formData.upn) ? formData.upn : [formData.upn];
  const upn = formData.customValue;

  consoleLog(`Unlinking ${upn} from personas:`, upns);

  for(const unlinkUpn of upns) {
    await core.graph.unlinkPersonas(upn, unlinkUpn, directorySource.sid);
  }
  return core.mod.personaTable.update({ tableFormId: formData.tableFormId });
}

/**
 * @description Generate the next ID for a persona type
 * 
 * @param {"Participant" || "Activity"} type - The persona type
 * @returns {number} - The next ID
 */
async function nextId(type) {
  // Get the next ID from the config database
  let nextId = await core.config.readConfig(`next${type}Id`) || 10000; 

  // Verify that graph does not have a lower ID
  const results = await core.graph.readPersonas([{ 
    type: "field",
    key: "platform",
    value: "directory",
    operator: "=",
    not: false
  },{
    type: "field",
    key: "type",
    value: type,
    operator: "=",
    not: false
  }]);

  const personas = results.raw.records.map(node => node._fields[0].properties);

  for(const persona of personas) {
    const id = parseInt(persona.id);
    if(id > nextId) {
      nextId = id + 1;
    }
  }

  // update the configuration database 
  await core.config.writeConfig({ [`next${type}Id`]: nextId + 1 });

  return nextId;
}

/**
 * @description Render the CSV pane
 * 
 * @returns {string} - Compiled HTML content for the CSV pane
 */
async function csvPane() {
  return csv.csvPane();
}

/**
 * @description Add a CSV file to the directory
 * 
 * @param {object} formData - Data from the CSV form submission
 * @returns {string} - Compiled HTML content for the CSV pane
 */
async function csvAddFile(formData) {
  return csv.csvAddFile(formData);
}

/**
 * @description Delete a CSV file from the directory
 * 
 * @param {object} formData - Data from the CSV form submission
 * @returns {string} - Compiled HTML content for the CSV pane
 */
async function csvDeleteFile(formData) {
  return csv.csvDeleteFile(formData);
}

/**
 * @description Merge CSV files with the Directory as source
 * 
 * @param {object} formData - Data from the CSV form submission
 * @returns {string} - Compiled HTML content for the CSV pane
 */
async function csvMerge(formData) {
  return csv.csvMerge(formData, directorySource);
}

function getPersonaCustomProperties(persona) {
  const keysToFilterOut = [
    "upn",
    "control",
    "obey",
    "directoryNote",
  ];

  const filteredProperties = Object.entries(persona).reduce((accumulator, [key, value]) => {
    if (!keysToFilterOut.includes(key)) {
      accumulator[key] = value;
    }
    return accumulator;
  }, {});
  const filteredPropertiesArray = Object.keys(filteredProperties).map(key => ({ key: key, value: filteredProperties[key] }));
  const sortedPropertiesArray = filteredPropertiesArray.sort((a, b) => a.key.localeCompare(b.key));
  return sortedPropertiesArray;
}

/**
 * @description Provide a detail subpane for a persona
 * @param {string} upn 
 * @returns {object} - The subpane object
 */
async function getDetailSubpane(upn) {
  // Find a persona object in the graph
  const persona = await core.graph.readPersona(upn);
  if (!persona) {
    console.error(`Persona not found for upn: ${upn}`);
    return {};
  }

  // Get the custom properties for grid display
  const customProperties = getPersonaCustomProperties(persona);
  const directoryNote = persona.directoryNote;
  
  // Define the configuration for the tables we want to display
  const aliasTableConfig = {
    tableFormId: "directory-subpane-alias",
    forceFilters: [
      {
        "type":"agency",
        "key":"obey",
        "levels": ["ALIAS"],
        "depth": 1,
        "filter": [
          {
            "type":"field",
            "key":"upn",
            "value":upn,
            "operator":"=",
          }
        ],
      }
    ]
  };
  const controlTableConfig = {
    tableFormId: "directory-subpane-control",
    action: {
      label: "Unlink",
      endpoint: "/mod/directory/unlinkPersonas",
      customValue: upn,
    },
    forceFilters: [
      {
        "type":"agency",
        "key":"obey",
        "depth": [1, 1],
        "levels": ["*"],
        "filter": [
          {
            "type":"agency",
            "key":"obey",
            "levels": ["ALIAS"],
            "depth": 1,
            "filter": [
              {
                "type":"field",
                "key":"upn",
                "value":upn,
                "operator":"=",
              }
            ],
          }
        ],
      },
      {
        "type":"field",
        "key":"upn",
        "value":upn,
        "operator":"<>",
      }
    ]
  }
  const obeyTableConfig = {
    tableFormId: "directory-subpane-obey",
    action: {
      label: "Unlink",
      endpoint: "/mod/directory/unlinkPersonas",
      customValue: upn,
    },
    forceFilters: [
      {
        "type":"agency",
        "key":"control",
        "levels": ["*"],
        "depth": [1, 1],
        "filter": [
          {
            "type":"agency",
            "key":"obey",
            "levels": ["ALIAS"],
            "depth": 1,
            "filter": [
              {
                "type":"field",
                "key":"upn",
                "value":upn,
                "operator":"=",
              }
            ],
          }
        ],
      },
      {
        "type":"field",
        "key":"upn",
        "value":upn,
        "operator":"<>",
      }
    ]
  }

  // Build Table HTML
  const aliasTableHtml = await core.mod.personaTable.getTable(aliasTableConfig);
  const controlTableHtml = await core.mod.personaTable.getTable(controlTableConfig);
  const obeyTableHtml = await core.mod.personaTable.getTable(obeyTableConfig);

  // Combine all of the data into a single object
  const data = {
    persona,
    customProperties,
    aliasTableHtml,
    controlTableHtml,
    obeyTableHtml,
  };

  // Build the subpane markup
  const markup = core.client.render('directoryDetailSubpane.hbs', data);

  return markup;
}

async function setDetailSubpaneNote(formData) {

  console.log(`Setting note for ${formData.upn}: ${formData.note}`);

  const persona = await core.persona.newFromUpn(formData.upn);
  persona.directoryNote = formData.note;
  await core.graph.mergePersona(persona, directorySource);

  return `Updated at ${new Date().toISOString().slice(11, 19)}`;
}

async function backup(clientData) {
    const file = await core.graph.backupSource(directorySource.sid);
    const fileName = `directory_backup_${new Date().toISOString().slice(0, 10)}.json`;
    
    // Definte the file type
    const type = "application/json";
  
    return {file, fileName, type};
}

async function restore(clientData) {
  const file = clientData.file.buffer.toString();
  // const file = clientData.file;
  const json = JSON.parse(file);
  
  core.check.sourceStoreObject(json);

  if(!json.source || !json.source.sid || json.source.sid !== directorySource.sid) {
    throw new Error("Invalid source in backup file");
  }

  await core.graph.restoreSource(json);

  return redraw();
}

/**
 * @description Initialize the module and register partials
 * @returns {void}
 */
async function init(){
  await core.client.registerPartials();
}

module.exports = {
  mainPane,
  csvPane,
  csvAddFile,
  csvDeleteFile,
  csvMerge,
  addParticipant,
  addPersona,
  addActivity,
  deletePersonas,
  linkPersonas,
  unlinkPersonas,
  getDetailSubpane,
  setDetailSubpaneNote,
  backup,
  restore,
  init,
};
